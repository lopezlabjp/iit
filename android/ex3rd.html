<!DOCTYPE html>
<html lang="ja">
<head>
<title>ITX1:Aoyama Gakuin University - 3rd</title>
	<link rel="stylesheet" type="text/css" href="assets/css/itx1.css">
	<link href="assets/plugins/bootstrap/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/vs.min.css">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
	<link href="assets/plugins/highlight/styles/default.css" rel="stylesheet">
	<script href="assets/plugins/highlight/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous">
</head>
<body>
<div class="container">
  <div class="title">
    <h1>第3回 Get Input from the User / ユーザーから入力を取得する</h1>
  </div>
  <p style="text-align: right;">
    最終更新日：2024年04月16日
  </p>
  <p><a href="index.html">ホームへ戻る</a></p>
  <div class="contents">
    <h4>第2回のプロジェクト、"<strong>LG First Android GUI</strong>" 、を続けて使用する。</h4>

    <!------ 古いバージョン ----    
    <p>レイアウトは、<strong>演習問題2_3で作成した Layout をコピーして、名前を変更せよ。 </strong> 
	<ul>
			<li>Activity　→　<strong>InputActivity.java</strong><br>
			InputActivity の package を <strong>jp.aoyama.a00001.xxinputactivity</strong> (a00001は学生番号にちなんだ番号、はxx各自の名前の頭文字)</li>
			<li>Layout　→　<strong>layout_input.xml</strong><br>
			  以下の属性を変更することも忘れずに（この課題に利用されるすべてのファイルにて確認を）！
<pre>
<code class="xml hljs">
tools:context="jp.aoyama.a00001.xxinputactivity.InputActivity"
</code></pre>
			</li>
			<li>Manifest.xmlにおいて、ベースとなるパッケージを「jp.aoyama.a00001.xxinputactivity」にする。</li>
			<li>build.gradle フィアルにおいて、applicationId を「jp.aoyama.a00001.xxinputactivity」にする。</li>
	  </ul>
	  </p>
---------------------->
    
<div class="practice practice-checkpoint">
	<h3>第3回の提出課題一覧</h3>
    <strong>【チェック合格条件】</strong>各スクリーンショットと内容が一致すること（色は問わない）
    <ul>
      <li><strong>演習問題3_1：図１と同じ画面構成と画面遷移ができること（必須）</strong></li>
      <li><strong>演習問題3_2：（必須）</strong></li>
      <li><strong>演習問題3_3：（必須）</strong></li>
      <li>演習問題3_4（任意）</li>
    </ul>
</div>
	
<div class="practice">
	<h3>演習問題3_1: Clickable image から他の Activity を立ち上げる</h3>
	<ol type="a">
    <li>下記「A. Clickable images」の説明を参考に、レイアウトの左下に【設定画面】を開くための&nbsp; <strong>FloatingActionButton</strong> &nbsp;型ボタンを追加する。<strong>アイコンを図１左下と同じ形</strong>（歯車マーク）のものにする（色、大きさは問わない）。</li>
    <li><strong>SetActivity</strong> という名の新しい "Empty Views Activity" を作成する。
      <ol>
        <li>SetActivity のレイアウトの名を <strong>activity_set</strong> とする。</li>
        <li>SetActivity のタイトルを <strong>"Settings"</strong> とする。</li>
        <li>SetActivity の<strong>戻る（ホーム）ボタン</strong>を表示させる。</li>
      </ol> 
    </li>
	  <li>下記「B. Activity callback」の説明を参考に、「a」で作成した<strong>【設定】ボタンをタップた際</strong>、
      <ol>
        <li><strong>SetActivity</strong> を起動させる。</li>
        <li>“opening user setting”を表示する <strong>Toast</strong> を表示させる。</li>
        <li>SetActivity の戻る（ホーム）ボタンをタップした時、<strong>アクティビティが終了</strong>（ <strong>finish()</strong> メソッド）し、再び MainActivity が表示されるようにする。</li>
      </ol>
    </li>
	</ol>
  <p>演習問題3_1で実装するUIと機能の遷移状態は図１にまとめている。</p>
	<figure class="figure" align="center">
		<img src="./assets/images/ex3rd/setting_open-close.png" alt="setting_open-close.png" class="figure-img img-fluid rounded" width="60%">    
	  <figcaption class="figure-caption text-center">図１．課題3_1を実行したときの画面構成（左はMainActivity、右はSetActivity）と機能遷移</figcaption>
  </div>
	
	<hr>

    <h4>前提知識</h4>
    <ul>
      <li>テンプレートからAndroidStudioプロジェクトを作成し、main layoutを生成する。</li>
      <li><strong>Layout Editor</strong> を使用して UI 要素（ボタン、テキスト）を作成、配置、および編集する。</li>
      <li><strong>findViewById()</strong> を使用して、コードからUI要素にアクセスする。</li>
      <li><strong>Button</strong> のクリックを処理する。</li>
      <li>様々な<strong>リソース</strong>（layout, string, menu, drawable, etc.）の意味を理解し、作成・編集する。</li>
      <li>接続されたデバイス・エミュレータでアプリを実行する。</li>
    </ul>
	  
    <h4>この課題で学ぶこと</h4>
    <ul>
      <li><strong>Toast</strong> メッセージを表示する。</li>
      <li>Activity を起動・終了する方法。</li>
      <li>ユーザからの情報を入力するための様々な View 要素を把握する。</li>
      <li>画面が変わっても入力された情報を維持する方法（static な Bundle 変数）</li>
      <li>アプリを閉じても入力された情報を維持する方法（shared preference）</li>
    </ul>
	  
  
<h3>A. Clickable images / クリック可能な画像</h3>
    <h4>概要</h4>
    <p>Android搭載デバイスの画面に表示されるユーザーインターフェイス（UI）は、<strong>ビュー（View）</strong>と呼ばれるオブジェクトの階層で構成されている。 画面のすべての要素はViewである。Viewクラスは、<strong>すべてのUIコンポーネントの基本的な構成要素</strong>を表す。 Viewは、Button要素をはじめとするインタラクティブなUIコンポーネントを提供するクラスの基本クラスである。<br>
      <strong>Buttonは、ユーザーがタップまたはクリックしてアクションを実行できるUI要素</strong>です。<br>
      <strong> ImageView</strong>などの任意のViewをタップまたはクリックできるUI要素に変えることができます。ImageViewの画像は、プロジェクトの<strong>drawablesフォルダー</strong>に保存する必要があります。<br>
      この実習では、ユーザーがタップまたはクリックできる要素として画像を使用する方法を学習します。 </p>
	  
    <h4>FloatingActionButtonの追加</h4>
    <p>AndroidStudioのアイコンのセットからアイコンを選択できます。次の手順を実行します：
    <ol>
      <li><strong>Project > Android</strong>パネルで<strong> res </strong>（リソース）を展開し、<strong> drawable </strong>フォルダーを右クリック</li>
      <li><strong> New > Image Asset </strong>を選択し、イメージアセット設定ダイアログが表示される</li>
      <li>ダイアログの上部にあるドロップダウンメニューで<strong> Action Bar と Tab Icons </strong>を選択</li>
      <li>「名前」フィールドのic_action_nameを<strong> ic_set </strong>に変更</li>
      <li>クリップアート画像をクリックして、以下の クリップアート画像をアイコンとして選択<br>
        <img src="./assets/images/ex3rd/ic_set.png" class="figure-img img-fluid rounded" alt="ic_set.png"> </li>
      <li><strong>Theme</strong> ドロップダウンメニューから <strong>CUSTOM/HOLO_DARK/HOLO_LIGHT</strong> のどちらかを選択する。これにより、アイコンが暗い色（または黒）の背景に対して白に設定される。Next をクリックする。</li>
      <li>次のダイアログで<strong> 完了/Finish </strong>をクリックする。</li>
      <li>Layout Editor のデザインモードにおいて、Palette の Buttons カテゴリーから<strong> FloatingActionButton </strong>を選択し、以下のスクリーンショットと同じ位置におく。<br>
        アイコン選択の際、<strong>Drawable の中に先ほど追加したアイコンを選定</strong></li>
    </ol>
    <figure class="figure">
      <img width="75%" src="./assets/images/ex3rd/screenshot_1.png" class="figure-img img-fluid rounded" alt="screenshot_1.png">
      <figcaption class="figure-caption text-center">図２．Floating Action Buttonの配置</figcaption>
    </figure>
    </p>
	
    <h3>B. Activity callback / 他 Activity の起動と終了</h3>
    <h4>Activity の追加</h4>
    <p> 前のレッスンで学習したように、アクティビティは、ユーザーが単一の焦点を絞ったタスクを実行できるアプリ内の単一の画面を表す。 <strong>MAinActivity.java</strong>という1つのアクティビティがすでにある。 次に、<strong>SetActivity.java</strong>という別のアクティビティを追加する。<br>
      左側の列にある<strong>jp.aoyama.t23428.lgfirstandroidgui</strong>フォルダーを右クリック（またはControlキーを押しながらクリック）して、[New]&gt; [Activity]&gt; [Empty Views Activity] を選択する。
      アクティビティ名を<strong>SetActivity</strong>に、レイアウト名をactivity_setに編集します。 他のオプションはそのままにして、[完了]をクリックする。<br>
      これで、<strong>SetActivity</strong>クラスが<strong>InputActivity</strong>と一緒にjavaフォルダーにリストされ、<strong>activity_set.xml</strong>が <strong>layout</strong> フォルダーにリストされるはず。 </p>
	
    <h4>Action の変更</h4>
	<p>
		このステップでは、FloatingActionButton のアクションを変更して、新しい Activity を起動する。
		<ol>
			<li>MainActivity.java を開く</li>
			<li>設定アイコンをタップした際、 <strong>SetActivity</strong> が起動されるよう、<strong>myBtnClickView view）</strong>メソッド（演習課題2で作成しているはずですが、設定ボタン専用のクリック処理メソッドを作成しても良い）に<strong>明示的 Intent</strong> の作成コードを追加する（必要に応じて else if 文に囲めて）：</li>
      
<pre><code class="java hljs">  
	Intent intent = new Intent(InputActivity.this, SetActivity.class);
	startActivity(intent);
  
</code></pre>
      
		  <li>アプリを実行し、設定アイコンを使用する floating action button をタップすると、空白の <strong>Activity</strong> （SetActivity）が表示されることを確認。</li>
			<li>SetActivity を終了させ、呼び出した Activity（MainActivity）に戻るには、 <strong>finish()</strong> メソッドを使う。今回は、SetActivityの「戻る」ボタンのタップで終了させる。</li>
        </ol>
	</p>
	
	<h4>Toast の作成</h4>
	<p>
    このタスクでは、画像・ボタンがタップされた際示す<strong>Toast</strong>メッセージを表示する方法を学ぶ。 </p>
	<ol>
	  <li><strong>string.xml</strong> リソースに Toast が表示するメッセージ、"<strong>opening user setting</strong>"、を用意する。</li>
	  <li><strong>InputActivity</strong> を開き、以下の <strong>displayToast()</strong> メソッドを追加する。&nbsp;</li>
<pre>
<code class="java hljs">
	public void displayToast(String message) {
		Toast.makeText(getApplicationContext(), message,　Toast.LENGTH_SHORT).show();
	}
</code>
</pre>
		<li><strong>myBtnClick() </strong>メソッド内に、作成した <strong>displayToast() </strong>メソッドの呼び出しを、設定ボタンのクリック時コードに追加し、メソッドの属性に <strong>string.xml </strong>に用意した文字列が入るようにする。</li>
<pre>
<code class="java hljs">
	public void myBtnClick(View v) {
		/** 設定ボタンのクリック処理に追加する　**/
		displayToast(getString(xxxxxxxxx));
	}
  
</code></pre>
    </ol>

  </div>
	
  <hr>
 <div class="practice">
	<h3>演習問題3_2: </h3>
   <h5><strong>「Input Control」の説明を参考にしながら、UI が図2~4と同じになるように、「a」～「g」の要素と機能を実装する。</strong></h5>
		<ol type="a">
			<li>端末/エミュレータの設定にて言語を「<strong>英語（米国）</strong>」を追加し、キーボードを<strong>Qwerty</strong> に指定する（Gboard）。
          </li>
			<li><strong>名前</strong>を入力するフィールドは、Layout Editor の Palette の「<strong>PlainText</strong>」要素で作成する。名前の頭文字が自動的に大文字入力になるため、属性（attributes）の <strong>inputType</strong> を適切に設定する。</li>
			<li><strong>学生番号</strong>を入力フィールドは、Layout Editor の Palette の「<strong>Number</strong>」要素で作成する。そうすることで、入力の際テンキーが自動で表示される。</li>
			<li><strong>メールアドレス</strong>を入力フィールドは、Layout Editor の Palette の「<strong>E-mail</strong>」要素で作成する。そうすることで、入力の際キーボードに「@」キーが自動で表示される。</li>
<li><strong>電話番号</strong>を入力するフィールドは、Layout Editor の Palette の「<strong>Phone</strong>」要素で作成する。そうすることで、入力の際テンキーが自動で表示される。</li>
			<li><strong>電話番号の種類</strong>は、家・仕事・携帯・その他」の４つの選択肢を用意する。そのため、Layout Editor の Palette の widget カテゴリにある「<strong>spinner</strong> 」を利用する。電話番号の種類を選定・変更する度に、選択した種類の名前が <strong>Toast</strong> で表示されるようにする。</li>
			<li><strong>通学手段</strong>（Mobility）は「<strong>RadioButton</strong>」で作成する（横並び、縦並び、どちらでもOK）。１つの RadioButton しか選択できないように、「<strong>RadioGroup</strong>」で囲むこと。RadioButton の <strong>onClick</strong> ハンドラーを設定し、選択する度、どのボタンが選択されたかを <strong>Toast</strong> を用いて表示させる。</li>
		</ol>

		<table><tr>
			<td align="center">
				<figure class="figure">
					<img src="./assets/images/ex3rd/exercise3_2_name.png" alt="exercise3_2_name.png" class="figure-img img-fluid rounded" width="80%">
					<figcaption class="figure-caption text-center">図３．課題3_2の完成時スクリーンショット（Name入力時）</figcaption>
				</figure>
			</td>
			<td align="center">
				<figure class="figure">
					<img src="./assets/images/ex3rd/exercise3_2_e-mail_mobile.png" alt="exercise3_2_e-mail_mobile.png" class="figure-img img-fluid rounded" width="80%">
					<figcaption class="figure-caption text-center">図４．課題3_2の完成時スクリーンショット（e-mail入力時）</figcaption>
				</figure>
			</td>
			<td align="center">
				<figure class="figure">
					<img src="./assets/images/ex3rd/exercise3_2_phone_home.png" alt="exercise3_2_phone_home.png" class="figure-img img-fluid rounded" width="80%">
					<figcaption class="figure-caption text-center">図５．課題3_2の完成時スクリーンショット（電話番号入力時）</figcaption>
				</figure>
			</td>
	</tr></table>
	</div>
	
	<h3>Input Control / 入力コントロール</h3>
  <div class="contents">
	<h4>概要 / Introduction</h4>
	  <p>
		  ユーザーがテキストまたは数字を入力できるようにするには、<strong>EditText</strong> 要素を使用する。<br>
		  一部の入力コントロールは、表示されるキーボードのタイプを定義するEditText属性であり、<strong>ユーザーがデータを簡単に入力できるようにしている</strong>。たとえば、<strong>android:inputType</strong> 属性に [<strong>phone</strong>] を選択すると、文字キーボードの代わりに<strong>テンキーを表示する</strong>ことができる。
	  </p>
	  <p>
	    他の入力コントロールにより、ユーザーは簡単に選択できる。たとえば、<strong>RadioButton</strong> 要素を使用すると、ユーザーはアイテムのセットから1つ（そして1つだけ）のアイテムを選択できる。
	  </p>
	  <p>
	    この課題では、属性を使用して画面上のキーボードの外観を制御し、EditTextのデータ入力のタイプを設定する。 また、<strong>SetActivity</strong>アプリに radio button を追加して、ユーザーが一連のアイテムから1つのアイテムを選択できるようにする。
	  </p>
	</div>
  
  <div class="contents">
	<h4>この課題で学ぶこと</h4>
	<ul>
			<li>入力方法を変更して、提案、自動大文字化および、パスワードの難読化を有効にする方法</li>
			<li>一般的なオンスクリーンキーボードを電話のキーパッドまたはその他の特殊なキーボードに変更する方法</li>
			<li>ユーザーがアイテムのセットから1つのアイテムを選択するための radio button を追加する方法</li>
			<li>Spinner（スピナー）を追加して、ユーザーが値を選択できるドロップダウンメニューを表示する方法</li>
	  </ul>
		
	  <h4>Radio buttons の利用とイベント取得</h4>
	  <p>
		  Radio buttons は<strong>複数の選択肢の内１つのみのオプションを選択</strong>したいとき役に立つ入力コントロール要素です。
		  Spinnerと比べて、すべての選択肢が一度に見える。<br>
         <strong> SetActivity</strong> に radio buttons を追加するには、まず Layout Editor を用いて <strong>activity_set.xml</strong> レイアウトに <strong>RadioButton</strong> 要素を追加する。<br>
		  Radio buttons の選択は相互に排他的であるため、<strong>RadioGroup</strong> 内でそれらをグループ化し、グループ化することにより、Android システムは一度に１つのラジオボタンのみを選択できるようにする。
	  </p>
	  <p>
	    Radio buttons のクリック（選択）イベントを取得するため、通常のボタンと同じく、Layout File 内の各 RadioButton 要素に対して、<strong>onClick</strong> 属性を設定する（下記例を参照）。
<pre>
<code class="xml hljs">
	android:onClick="onRadioButtonClicked"
	
</code>
</pre>
	  </p>
	<p>
	  	各 radio button 要素の android:onClick 属性において、クリックイベントを処理するため <strong>onRadioButtonClicked()</strong> メソッドを指定すれば、<strong>SetActivity クラスに新しい onRadioButtonClicked()</strong> メソッドを追加する必要がある。（下記参照）。
	</p>
	  
<pre>
<code class="java hljs">
	public void onRadioButtonClicked(View view) {
		// Is the button now checked?
		/** ここで必要なコードを書く **/
        <!-- boolean checked = ((RadioButton) view).isChecked(); -->
		// Check which radio button was clicked.
		/** ここで必要なコードを書く **/
        <!-- switch (view.getId()) {
            case R.id.sameday:
                if (checked)
                    // Same day service
                    displayToast(getString(R.string.same_day_messenger_service));
                break;
            case R.id.nextday:
                if (checked)
                    // Next day delivery
                    displayToast(getString(R.string.next_day_ground_delivery));
                break;
            case R.id.pickup:
                if (checked)
                    // Pick up
                    displayToast(getString(R.string.pick_up));
                break;
            default:
                // Do nothing.
                break;
        } -->
	}
</code>
</pre>
	
	<h4>Spinner の利用とイベント取得</h4>
	<p>
		<strong> Spinner</strong> は、<strong>セットから1つの値を選択する簡単な方法</strong>を提供する。Spinner を<strong>タッチすると、使用可能なすべての値を含むドロップダウンリストが表示</strong>され、ユーザーはそこから1つを選択できる。 <br>
		2つまたは3つの選択肢しか提供していない場合、レイアウトに余裕があれば、選択肢に radio buttons を使用することをお勧めする。ただし、3つ以上の選択肢がある場合、Spinner は非常にうまく機能し、必要に応じてスクロールしてアイテムを表示し、レイアウトのスペースをほとんど占有しない。
	</p>
	<p>
		電話番号（自宅、職場、携帯電話、その他など）のラベルを選択する方法を提供するために、アプリの SetActivity レイアウト（<strong>activity_set.xml</strong>）に <strong>Spinner</strong> を追加して、電話番号フィールドのすぐ横に表示することができる。<br>
		Spinner を追加するには、まず Layout Editor を用いて <strong>activity_set.xml</strong> レイアウトに <strong>Spinner</strong> 要素を追加する。<br>
	</p>
	<p>
		<strong> Spinner の選択結果イベント</strong>を取得するため、onClick ではなく、<strong>Listener</strong> を用いる。
	  Spinner とそのリスナーをアクティブ化するには、<strong>AdapterView.OnItemSelectedListener</strong> <strong>インターフェイスを実装</strong>する。これには、<strong>onItemSelected()</strong> および <strong>onNothingSelected() </strong>コールバックメソッドも追加する必要がある。また、Spinnerオブジェクトに対して <strong>setOnItemSelectedListener(this)</strong> メソッドを呼び出すことで、そのSpinnerオブジェクトとListenerとなったclassを対応させる。<br>
<pre>
<code class="java hljs">
public class SetActivity extends AppCompatActivity implements　AdapterView.OnItemSelectedListener {
		//...
    protected void onCreate(Bundle savedInstanceState) {
        //...
        Spinner spinner = (Spinner) findViewById(R.id.spinner);
        spinner.setOnItemSelectedListener(this);
        //...
    }
    //...
}
</code>
</pre>
	</p>
	<p>
	  <strong> strings.xml</strong> を開き、Spinner の選択可能な値（Home、Work、Mobile、およびOther）を文字列配列 <strong>labels_array</strong> として定義する。<br>
    <pre>
<code class="xml hljs">
	&lt;string-array name="labels_array">
        &lt;item>Home&lt;/item>
        &lt;item>Work&lt;/item>
        &lt;item>Mobile&lt;/item>
        &lt;item>Other&lt;/item>
	&lt;/string-array>	
	
</code>
</pre>
	</p>	
	<p>
		<strong> Spinner </strong>の選択コールバックを定義するには、SetActivity クラスを変更して、次のようにAdapterView.OnItemSelectedListenerインターフェイスに必要な <strong>onItemSelected()</strong> メソッドを実装する。この例では、空の <strong>onNothingSelected()</strong> コールバックメソッドにコードを追加する必要はありません。<br>
      <strong> getItemAtPosition()</strong> を使用して spinner で選択したアイテムを取得し、そのアイテムを spinnerLabel 変数に割り当てる。<br>
    <pre>
<code class="java hljs">
	@Override
	public void onItemSelected(AdapterView<?> adapterView, View view, int i, long l) {
		spinnerLabel = adapterView.getItemAtPosition(i).toString();
		/** Toast 表示コードを追加する **/<!-- displayToast(spinnerLabel); -->
	}

	@Override
	public void onNothingSelected(AdapterView<?> adapterView) { }
   
</code>
</pre>
		
	</p>
		  
      <h4> より詳しい情報は <a href="https://google-developer-training.github.io/android-developer-fundamentals-course-concepts-v2/unit-2-user-experience/lesson-4-user-interaction/4-2-c-input-controls/4-2-c-input-controls.html">Android Developers Guide</a> を参照すること。 </h4> 
  </div>

	<hr>

	<div class="practice">
	<h3>演習問題3_3：Saving data into a Bundle</h3>
    <h5>「Androidでのデータ永続化」の説明を参考にしつつ、Bundle型 static 変数を用いて、「a」～「d」を実装する。<h5>
		<ol type="a">
      <li><strong>入力した情報を保存</strong>するための Floating Action Button を用意する（図６を参照：フロッピーディスク形状）。</li>
      <li><strong>保存ボタンをタップ</strong>したときと、Action Bar の「戻る」ボタンをタップしたとき、各フィールドの値を <strong>Bundle Class </strong>の <strong>static</strong> 変数に保存する。</li>
			<li>また、MainActivity より SetActivity を呼び出した際、２回目以降（Bundle 変数はnullではなく、データ入っている状態）、Bundle に保存した値で、各フィールドを自動的に入力・設定する（Fieldの種類によって、入力・設定の仕方が少し変わる）。</li>
      <li>初回設定（SetActivity）を起動する際、図5、２回目以降図6のようになっていることを確認する。</li>
		</ol>
      <p>
      【hint】フィールドによって、「c」で自動入力しやすいように、Bundle に保存するべき内容を考えること。
        </p>
		<table><tr>
			<td align="center">
				<figure class="figure">
					<img src="./assets/images/ex3rd/exercise3_2_e-mail_mobile.png" alt="exercise3_2_e-mail_mobile.png" class="figure-img img-fluid rounded" width="60%">
					<figcaption class="figure-caption text-center">図5．課題3_3において、ActivitySetを初めて表示した際のスクリーンショット</figcaption>
				</figure>
			</td>
			<td align="center">
				<figure class="figure">
					<img src="./assets/images/ex3rd/exercise3_3_input.png" alt="exercise3_3_input.png" class="figure-img img-fluid rounded" width="60%">
					<figcaption class="figure-caption text-center">図6．課題3_3の完成時スクリーンショット（データ入力後、2回目の呼び出し）</figcaption>
				</figure>
			</td>
	  </tr></table>
    </div>

<h3>Androidでのデータ永続化</h3>
  <div class="content">
    <h4>Bundle について / How to use Bundle</h4>
	  <p>
		  Android には Activityのライフサイクルがあります。<br>
		  別のActivityが前面に来るなどにして、メモリが不足した場合にActivityが破棄されることがある。<br>
		  このとき、メモリ上にだけ展開されていたインスタンス変数などの値も破棄されてしまう。<br>
		  再度呼び出されるときは、もう一度Activityを生成しなおすため、前回の状態は失われている。<br>
	    そこで、前回と同じ状態に復元できるようにするために、状態を保存、復元するクラスとしてAndroidが準備してくれているのが<strong>Bundle</strong>です。<br>
簡単に言うと<strong>BundleはOSの判断で強制的に停止、終了する時に一時的にデータを格納するクラス</strong>です。<br>
		  作成は以下の手順で行う。
    <pre>
<code class="java hljs">
	Bundle 変数 = new Bundle();
	変数.putString("キー1", "文字列1");
	変数.putInt("キー2", 数字1);
</code></pre>		
	  
	  値を受け取る場合は以下の手順で行う。
    <pre>
<code class="java hljs">
	String 変数 = args.getString("キー1");
	int 変数 = args.getInt("キー2");
</code></pre>		
	  </p>
	</div>
	　<!-- END <h3>Save Data</h3>-->
    

	<div class="practice">
	<h3>演習問題3_4：Saving data with shared preferences（任意） </h3>
		<ol type="a">
		  <li>SharedPreference を用いて、設定を一度しか入力しなくて済むようにする。<br>
			Activity 変更したり、アプリを閉じたりしても、再び「設定」を開いた際、保存した内容が自動入力（表示）される。</li>
			
		</ol>
	</div>	
    
	<div class="content">

	  <h4>SharedPreferencesでデータを永続化する / Save the default values in shared preferences</h4>
		<p>
		    アプリは、ユーザーがアプリを開いたときに、設定ごとに<strong>SharedPreferences</strong>ファイルに各値を保存する必要がある。<strong>比較的小さなコレクションの Key-Value</strong> を保存する場合は、<strong>SharedPreferences</strong> を使用することをおすすめします。
		</p>
	 	<p>
			<strong> SharedPreferences</strong> とは、<strong>boolean</strong>, <strong>float</strong>, <strong>int</strong>, <strong>long</strong>, <strong>String</strong> などのデータ型について、キーと値のペアを読み書きできるAPI。キーと値のペアは内部ストレージにxmlファイルとして保存される。初回アクセス以降はメモリ上に展開されたキャッシュからデータを取得するため、高速にアクセスできる。 </p>
			<p>
		API名「<strong>SharedPreferences</strong>」から誤解されることもあるが、厳密には「ユーザー設定」を保存するためのものではなく、ユーザーのハイスコアなどの単純なデータを保存する際に使われる。たとえば、下記のコードは、リソース文字列 <strong>R.string.preference_file_key</strong> で識別される共有環境設定ファイルにアクセスして、プライベート モードで開きます。これにより、この共有環境設定ファイルにアクセスできるのは、このアプリだけになります。共有環境設定ファイルに名前を付ける場合、対象アプリを一意に識別できる名前を使用してください。簡単な方法としては、アプリ ID をプレフィックスとしてファイル名の先頭に付ける方法があります。<br>
				例: "jp.aoyama.a00001.xxinputactivity.PREFERENCE_FILE_KEY"</p>
		
<pre>
<code class="java hljs">
	Context context = getActivity();
	SharedPreferences sharedPref = context.getSharedPreferences(
					getString(R.string.preference_file_key), 
					Context.MODE_PRIVATE);
</code></pre>		
		<p>
	    あるいは、アクティビティに対して共有環境設定ファイルが 1 つだけ必要な場合は、<strong>getPreferences() </strong>メソッドを使用します。 </p>
<pre><code class="java hljs">
	SharedPreferences sharedPref = getPreferences(Context.MODE_PRIVATE);
</code></pre>		
    <p>
			共有環境設定ファイルへの書き込み。
    <ul>
			<li><strong>SharedPreferences.edit() </strong>メソッドで<strong>SharedPreferences.Editor</strong> を作成</li>
			<li><strong>putInt()</strong> や <strong>putString() </strong>を呼び出し、<strong>Key</strong> - <strong>Value</strong>を渡す<br>
<i>（*保存したい項目ごとの Key を string.xml で定義する良い）</i></li>
			<li><strong>apply() </strong>または <strong>commit() </strong>を呼び出して、変更内容を保存<br>
			<i>（*apply()は非同期、commit()は同期的にディスクに書き込む）</i></li>
	  </ul>
		</p>
<pre><code class="java hljs">
	String user_name_value = ((EditText)findViewById(R.id.editTextName)).getText().toString());
	SharedPreferences.Editor editor = sharedPref.edit();
	editor.putString(getString(R.string.user_name_key), user_name_value);
	editor.commit();
</code></pre>		
				
    <p>
			共有環境設定ファイルから読み取る
    <ul>
			<li><strong>getInt()</strong> や <strong>getString()</strong>を呼び出し、値に対応するキーを指定する</li>
			<li>必要に応じて、Key が存在しない場合に返すデフォルト値を指定する（それもstring.xmlで定義すると良い）</li>
	  </ul>
		</p>
<pre><code class="java hljs">
    String user_name = sharedPref.getString(getString(R.string.user_name_key), DEFAULT_VALUE);
</code></pre>		

	  <p>
		  AndroidStudio の <strong>Device File Explorer からxmlファイルが実際に保存されていることが確認できる</strong>。<br>
		  「SharedPreferences」ファイルは、アプリのパッケージ内、<strong>Device File Explorer &gt; data &gt; data &gt; xxinputactivity</strong> 、の「<strong>shared_prefs</strong>」フォルダ内にある。<br>
		  つまり、アプリからしかアクセスできない内部ストレージ。</p>

	</div>


<!--
	<h3>データの保存 / Save Data</h3>
	<div class="content">
		<h4>ローカル データベースにデータを保存する</h4>
		<p>
			Room は、SQLite 全体を対象とする抽象化レイヤを提供し、SQLite を最大限に活用しつつ、スムーズなデータベース アクセスを可能にします。
			比較的大量の構造化データを処理するアプリは、そのデータをローカルに永続化することで大きなメリットを得ることができます。最も一般的なユースケースは、関連データのキャッシュを保存することです。これにより、デバイスがネットワークにアクセスできない場合でも、ユーザーはオフラインでコンテンツを閲覧することができます。ユーザーがコンテンツに変更を加えた場合は、デバイスがオンラインに戻った後にサーバーに同期されます。

Room を使用すれば、このような処理が自動的に実行されるため、SQLite の代わりに Room を使用することを強くおすすめします。SQLite API を直接使用したい場合は、SQLite を使用してデータを保存するをご覧ください。

アプリで Room を使用するには、アプリの build.gradle ファイルに次の依存関係を追加します。
<pre>
<code class="java hljs">
	dependencies {
	  def room_version = "2.2.6"

	  implementation "androidx.room:room-runtime:$room_version"
	  annotationProcessor "androidx.room:room-compiler:$room_version"

	  // optional - RxJava support for Room
	  implementation "androidx.room:room-rxjava2:$room_version"

	  // optional - Guava support for Room, including Optional and ListenableFuture
	  implementation "androidx.room:room-guava:$room_version"

	  // optional - Test helpers
	  testImplementation "androidx.room:room-testing:$room_version"
	}
</code>
</pre>			
		</p>
		<p>
			Room は、次の 3 つの主要コンポーネントで構成されます。

データベース: データベース ホルダーを格納し、アプリの永続化リレーショナル データに対する基盤接続のメイン アクセス ポイントとして機能します。

@Database アノテーション付きのクラスは、以下の条件を満たす必要があります。

RoomDatabase を拡張する抽象クラスであること。
データベースに関連付けられているエンティティのリストをアノテーション内に含めること。
引数が 0 個で、@Dao アノテーション付きのクラスを返す抽象メソッドを含むこと。
実行時に Room.databaseBuilder() または Room.inMemoryDatabaseBuilder() を呼び出すことで、Database のインスタンスを取得できます。

エンティティ: データベース内のテーブルを示します。

DAO: データベースにアクセスする際に使用するメソッドを格納します。

アプリは Room データベースを使用して、そのデータベースに関連付けられたデータアクセス オブジェクト（DAO）を取得します。次に、アプリは各 DAO を使用してデータベースからエンティティを取得し、各エンティティに加えた変更をデータベースに保存します。 最後に、アプリはエンティティを使用して、データベース内のテーブルの列に対応する値を取得、設定します。
			1 つのエンティティと 1 つの DAO を持つサンプル データベース構成の例を次のコード スニペットに示します。

			User</p>

<pre>
<code class="java hljs">
    @Entity
    public class User {
        @PrimaryKey
        public int uid;

        @ColumnInfo(name = "first_name")
        public String firstName;

        @ColumnInfo(name = "last_name")
        public String lastName;
    }
</code>
</pre>
			<p>
				UserDao</p>
<pre>
<code class="java hljs">
    @Dao
    public interface UserDao {
        @Query("SELECT * FROM user")
        List<User> getAll();

        @Query("SELECT * FROM user WHERE uid IN (:userIds)")
        List<User> loadAllByIds(int[] userIds);

        @Query("SELECT * FROM user WHERE first_name LIKE :first AND " +
               "last_name LIKE :last LIMIT 1")
        User findByName(String first, String last);

        @Insert
        void insertAll(User... users);

        @Delete
        void delete(User user);
    }
</code>
</pre>
<pre>
<code class="java hljs">

AppDatabase
    @Database(entities = {User.class}, version = 1)
    public abstract class AppDatabase extends RoomDatabase {
        public abstract UserDao userDao();
    }
</code>
</pre>
		上記のファイルを作成した後は、次のコードを使用することで、作成したデータベースのインスタンスを取得できます。
<pre>
<code class="java hljs">
	AppDatabase db = Room.databaseBuilder(getApplicationContext(), AppDatabase.class, "database-name").build();	
</code>
</pre>

		<h4>ローカル データベースにデータを保存する</h4>
	  <p>
				アプリバーの[UP]ナビゲーションボタンをSetActivityに追加するには、AndroidManifest.xmlファイルでその宣言を編集して、SetActivityの親をInputActivityとして定義する必要がある。 
	  </p>
<pre>
<code class="xml hljs">
	&lt;activity android:name=".SettingsActivity">&lt;/activity>
</code>
</pre>			
以下のように変更せよ。
<pre>
<code class="xml hljs">
	&lt;activity android:name=".SettingsActivity"
				android:label="Settings"
				android:parentActivityName=".MainActivity">
				&lt;meta-data
					android:name="android.support.PARENT_ACTIVITY"
					android:value=".MainActivity"/>
	&lt;/activity>
</code>
</pre>	
		</div>
		
-->
</div><!-- END 第3回-->
</body>
</html>