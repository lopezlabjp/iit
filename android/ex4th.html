<!DOCTYPE html>
<html lang="ja"> 
    <head>
        <title>ITX1:Aoyama Gakuin University - 4th</title>
	<link rel="stylesheet" type="text/css" href="assets/css/itx1.css">
	<link href="assets/plugins/bootstrap/css/bootstrap.min.css" rel="stylesheet">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/vs.min.css">
	<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>
	<link href="assets/plugins/highlight/styles/default.css" rel="stylesheet">
	<script href="assets/plugins/highlight/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-giJF6kkoqNQ00vy+HMDP7azOuL0xtbfIcaT9wjKHr8RbDVddVHyTfAAsrekwKmP1" crossorigin="anonymous">
    </head>
    <body>
        <div class="container">
            <div class="title">
                <h1>第4回　Input from and Output to Files / ファイルへの入出力</h1>
            </div>
			  <p style="text-align: right;">
				最終更新日：2024年4月30日
			  </p>
        <div class="contents">
        <div class="practice practice-checkpoint">
          <h3>本日の提出課題一覧</h3>
            <ol>
            <li><strong>演習問題4_1（必須）</strong></li>
            <li><strong>演習問題4_2（必須）</strong></li>
            <li><strong>演習問題4_3（必須）</strong></li>
            </ol>
        </div>
          
        <div class="practice">
<h3>演習問題4_1: Write a text file（必須）</h3>
          <p>「Androidストレージ、内部ストレージへアクセスする」などの説明を参考に、以下の内容を実施せよ。</p>
	<ol type="a">
		<li>SetActivity Class において、Save ボタンをタッチした際、演習問題3_4で記録した SharedPreference の中身（Bundleの中身）をテキストファイルに保存させる（結果は図２を参照）。<br>
		ファイル書式は「<strong>xxsetactivity_pref-20210427_150500.txt</strong>」になるようにすること。
		<ul>
		  <li>"xx" は各自の名前の頭文字</li>
		  <li>"20210427" は保存した年月日（例：2021年4月27日）</li>
		  <li>"150500" は保存した時刻（例：15時5分0秒）</li>
		  <li>現在の年月日と時刻は <a href="https://docs.oracle.com/javase/10/docs/api/java/util/Date.html">Date</a> class のオブジェクトから  取得できる。</li>
		  <li>Date オブジェクトを好みの文字列書式に出力するため、<a href="https://docs.oracle.com/javase/10/docs/api/java/text/SimpleDateFormat.html">SimpleDateFormat</a> classを用いる（使い方は先のリンクから調べること）。</li>
		</ul>
		</li>
		<li>InputActivity Class において、メニューバーの「SAVE」メニューを推した際、演習問題2_3で実装した“クリックしたボタンとメニューの名前をTextViewに表示する”の TextView オブジェクトの中身をテキストファイルに保存させる（結果は図３を参照）。<br>
		ファイル書式は「<strong>xxinputactivity_content-20210427_150500.txt</strong>」になるようにすること（“20210427_150500”は「a.」の指示と同様、クリック日時になるようにする）。</li>
	</ol>

	<table><tr>
		<td align="center">
			<figure class="figure">
				<img src="./assets/images/ex4th/device_explorer_data_files.png" alt="device_explorer_data_files.png" class="figure-img img-fluid rounded" width="80%">
				<figcaption class="figure-caption text-center">図１．保存後、Device Exlplorer にて確認できるアプリケーションのデータファイル。</figcaption>
			</figure>
		</td>
		</tr><tr>
		<td align="center">
			<figure class="figure">
				<img src="./assets/images/ex4th/preferences_file.png" alt="preferences_file.png" class="figure-img img-fluid rounded" width="100%">
				<figcaption class="figure-caption text-center">図２．Preference の中身を保存したテキストファイル</figcaption>
			</figure>
		</td></tr><tr>
		<td align="center">
			<figure class="figure">
				<img src="./assets/images/ex4th/content_file.png" alt="content_file.png" class="figure-img img-fluid rounded" width="100%">
				<figcaption class="figure-caption text-center">図３．TextViewの中身を保存したテキストファイル</figcaption>
			</figure>
		</td>

	</tr></table>
</div>

  
          
          
                <h3>Androidのストレージ</h3>
                <p>
					Android は、他のプラットフォームのディスクベース ファイル システムと同様のファイル システムを使用しています。システムには、アプリデータの保存方法として次のような選択肢が用意されている（<a href="https://developer.android.com/training/data-storage">Android Developers Guide</a>を参照）。<br>
                <ul>
					<li><strong>アプリ固有のストレージ</strong>: アプリ専用のファイルを、内部ストレージ ボリューム内の専用ディレクトリ、または外部ストレージ内の別の専用ディレクトリに保存します。他のアプリがアクセスできない機密情報の保存には、内部ストレージ内のディレクトリを使用します。</li>
						<li><strong>共有ストレージ</strong>: メディアやドキュメントなど、アプリが他のアプリと共有するファイルを保存します。</li>
						<li><strong>設定</strong>: 非公開のプリミティブ データを Key-Value ペアで保存します。</li>
						<li><strong>データベース</strong>: Room 永続ライブラリを使用して、構造化データを非公開のデータベースに保存します。</li>
					</ul>
				</p>
			  <h4>アプリ固有のファイル</h4>
			  <p>
					内部ストレージの場合、許可（PERMISSION）は不要。<br>
				  	外部ストレージのファイルにアクセスする場合、<strong>READ_EXTERNAL_STORAGE</strong> または <strong>WRITE_EXTERNAL_STORAGE</strong> の許可（PERMISSION）が必要。
					<ul>
						<li>内部ストレージからは <strong>getFilesDir() </strong>または getCacheDir()</li>
						<li>外部ストレージからは <strong>getExternalFilesDir() </strong>または getExternalCacheDir()</li>
					</ul>
				</p>
			  <h4>メディア</h4>
				<p>
					<strong> MediaStore API</strong>を用いる。<br>
基本的に、ファイルにアクセスする場合、<strong>READ_EXTERNAL_STORAGE</strong> または <strong>WRITE_EXTERNAL_STORAGE</strong> の許可（PERMISSION）が必要。              
				</p>

			  <h4>アプリ設定</h4>
				<p>
			    <strong> SharedPreference</strong> の <strong>Key</strong> - <strong>Value</strong>　ペアを用いる</p>

			  <p>
			  構造化データを保存するため、<strong>Room</strong> という永続ライブラリを用いる。 </p>
		
			</div>
	
		  <div class="contents">
				<h3>アプリ固有のファイルにアクセスする</h3>
			<p>多くの場合、アプリが作成するファイルは、他のアプリがアクセスする必要のないファイルまたはアクセスすべきでないファイルです。このようなアプリ固有のファイルには、以下の保存場所が用意されています。<br>
				ユーザーがアプリをアンインストールすると、アプリ固有のストレージに保存されているファイルは削除されます。そのため、アプリから独立して保持されることをユーザーが期待するファイルは、このストレージに保存すべきではありません。たとえば、ユーザーがアプリで写真を撮影した場合、通常はアプリをアンインストールした後でも写真にアクセスすることを望みます。その種のファイルは、共有ストレージを使用して適切なメディア コレクションに保存する必要があります。
				</p>
				<h4>内部ストレージへアクセスする </h4>
				<p>
					内部ストレージ内にはアプリごとにディレクトリが用意されており、アプリはそこでアプリ固有のファイルを整理できます。1 つのディレクトリはアプリの永続ファイル用に設計されています。<br>
					もう 1 つのディレクトリにはアプリのキャッシュ ファイルを格納します。これらのディレクトリ内のファイルを読み書きするためのシステム権限は必要ありません。
			</p><p>
					他のアプリは内部ストレージ内に保存されているファイルにアクセスできません。<br>
					したがって、内部ストレージは他のアプリがアクセスすべきでないアプリデータを保存する場所に適しています。
					</p><p>
					ただし、これらのディレクトリは容量が小さいことが多いため、注意が必要です。<br>
					アプリ固有のファイルを内部ストレージに書き込む前に、デバイスの空き領域を問い合わせる必要があります。
					</p><p>
					アプリの通常の永続ファイルは、コンテキスト オブジェクトの filesDir プロパティを使用してアクセスできるディレクトリにあります。<br>
					フレームワークには、このディレクトリ内のファイルにアクセスして保存する方法がいくつか用意されています。<br>
					<br>
					File API を使用すると、ファイルにアクセスして保存できます。
				</p>
				
<pre><code class="java hljs">
	String filename = "myfile.txt";
	File file = new File(getFilesDir(), filename);
</code></pre>
			  
			<p>
					File API を使用する代わりに、openFileOutput() を呼び出して、filesDir ディレクトリ内のファイルへの書き込みを行う FileOutputStream を取得することもできます。<br>
					次のコード スニペットは、ファイルにテキストを書き込む方法を示しています。
			</p>

<pre><code class="java hljs">
	String fileContents = "Hello world!";
	try {
		FileOutputStream fos = openFileOutput(filename, Context.MODE_PRIVATE)
		fos.write(fileContents.getBytes());
	}
</code></pre>
			  
			<p>
					fileList() を呼び出すことにより、filesDir ディレクトリ内のすべてのファイル名を含む配列を取得できます。次のコード スニペットをご覧ください。
<pre><code class="java hljs">
	File.createTempFile(filename, null, getCacheDir());
</code></pre>
			  アプリは、コンテキスト オブジェクトの cacheDir プロパティと File API を次のように使用して、このディレクトリ内のファイルにアクセスします。
<pre><code class="java hljs">
	File cacheFile = new File(getCacheDir(), filename);
</code></pre>
			  </p>
			  
			<p>
					キャッシュ ファイルは随時 Android によって自動的に削除されますが、だからといってキャッシュ ファイルのクリーンアップをシステムにまかせるべきではありません。内部ストレージ内のアプリのキャッシュ ファイルを常にメンテナンスする必要があります。<br>
					内部ストレージ内のキャッシュ ディレクトリからファイルを削除するには、次のいずれかのメソッドを使用します。<br>
			<ul><li>
					ファイルを表す File オブジェクトで使用する <strong>delete() </strong>メソッド。
                    <pre><code class="java hljs">
	cacheFile.delete();
</code></pre>
            </li>
						<li>アプリのコンテキストの <strong>deleteFile() </strong>メソッド。ファイル名を渡して使用します。
                          <pre><code class="java hljs">
	context.deleteFile(cacheFileName);
</code></pre>
				    </li>
			</ul>				
				</p>

				<p>
					アプリ固有のファイルを保存するのに十分な容量が内部ストレージにない場合は、代わりに外部ストレージの使用を検討してください。外部ストレージには、特定のアプリ内でのみユーザーに価値を提供するファイルを整理するためのディレクトリが用意されています。1 つのディレクトリはアプリの永続ファイル用に設計されています。もう 1 つのディレクトリにはアプリのキャッシュ ファイルを格納します。
				</p>
			<p>Android 9（API レベル 28）以下を実行するデバイスでは、適切なストレージ権限を持っていれば、どのアプリも外部ストレージ内のアプリ固有のファイルにアクセスできます。ユーザーがファイルをきめ細かく管理して整理できるように、Android 10（API レベル 29）以上をターゲットとするアプリには、外部ストレージに対する限定的なアクセス権がデフォルトで付与されます（そのようなストレージを対象範囲別ストレージと呼びます）。対象範囲別ストレージを有効にすると、アプリは他のアプリに属するアプリ固有のディレクトリにアクセスできなくなります。</p>
				<p>外部ストレージはユーザーが削除できる物理ボリューム上にあるため、外部ストレージとの間でアプリ固有のデータの読み取りまたは書き込みを行う前に、ボリュームにアクセスできることを確認する必要があります。<br>
				  ボリュームの状態を問い合わせるには、<strong>Environment.getExternalStorageState() </strong>を呼び出します。返された状態が MEDIA_MOUNTED の場合は、外部ストレージ内のアプリ固有のファイルの読み取りと書き込みを行うことができます。<strong>MEDIA_MOUNTED_READ_ONLY</strong> の場合は、それらのファイルの読み取りのみを行うことができます。<br>
たとえば、以下のメソッドはストレージが使用可能かどうかを判断するのに役立ちます。
            <pre><code class="java hljs">
	// Checks if a volume containing external storage is available for read and write.
	private boolean isExternalStorageWritable() {
		return Environment.getExternalStorageState() == Environment.MEDIA_MOUNTED;
	}
	// Checks if a volume containing external storage is available to at least read.
	private boolean isExternalStorageReadable() {
    	return Environment.getExternalStorageState() == Environment.MEDIA_MOUNTED ||
            Environment.getExternalStorageState() == Environment.MEDIA_MOUNTED_READ_ONLY;
	}
</code></pre>					
				</p>
			<h4>永続ファイルにアクセスする</h4>
				<p>
			    外部ストレージからアプリ固有のファイルにアクセスするには、次のコード スニペットに示すように、<strong>getExternalFilesDir() </strong>を呼び出します。 </p>
				<p>外部キャッシュ ディレクトリからファイルを削除するには、ファイルを表す File オブジェクトで delete() メソッドを使用します。</p>
				<p>Media Contents のように、特定のアプリ内でのみユーザーに価値を提供するメディア ファイルを使用する場合は、次のコード スニペットに示すように、外部ストレージ内のアプリ固有のディレクトリに保存することをおすすめします。</p>

	</div>


<!------------------------------------------------------->
<!----------------Get and Display Files List------------->
<!------------------------------------------------------->

<div class="practice">
<h3>演習問題4_2: Access to application's files（必須）</h3>
<p>「ファイルリストの取得と表示」の説明を参考に、以下の内容を実施せよ。</p>

  <ol type="a">
	  <li><strong>menu_action_bar.xml</strong> にある「Preview」メニュを「<strong>Open</strong>」に置き換える（表示される文字列とIDの変更）。</li>
	<li>新しいレイアウトファイル、<strong>open_layout.xml</strong> を作成し、その中に <strong>ListView</strong> コンポネントを入れる（「Palette → Legacy」から見つかる） 。</li>
	  <li>「Open」 メニューをタッチした時、InputActivity において、setContentViewメソッドを用いて、 content view が open_layout になるようにする。</li>
	  <li>ListView にアプリで保存したファイルのリストが表示されるようにする（図４を参照）。</li>
	</ol>
	
	<table><tr>
		<td align="center">
			<figure class="figure">
				<img src="./assets/images/ex4th/files_list.png" alt="files_list.png" class="figure-img img-fluid rounded" width="60%">
				<figcaption class="figure-caption text-center">図４．これまで保存したファイルのリスト表示結果。</figcaption>
			</figure>
		</td>
	</tr></table>

</div>	

<h3>ファイルリストの取得と表示 / Get and Display Files List</h3>
<div class="contents">
	<p><strong>fileList() </strong>を呼び出すことにより、アプリケーションの file directory 内のすべてのファイル名を含む配列を取得できる。</p>
<pre>
<code class="java hljs">	String[] files = fileList();	
</code>
</pre>
	<p>
	  <strong> UI にある情報のリスト（配列）を表示したいとき、ListView を用いる</strong>。ListView とデータを結びつくため、文字列データは <strong>ArrayList</strong>
<string> として保持する。<br>
	    ListView とリストを結びつけるのは、<strong>Adapter</strong>（アダプター）で、アダプターは android.widget.BaseAdapter から派生したオブジェクトです。<br>
	    特に配列やリストと結びついて使うために、 <strong>ArrayAdapter</strong> (android.widget.ArrayAdapter
        <t>) がある。<br>
          例えば、<em>listView</em> 変数は <em>findViewById()</em> を用いて、取得するListView オブジェクトだとして、ArrayAdapter を使って、 ListView にコレクションを結びつく方法は以下のコードになる。</t>
      </string>
    <pre>
<code class="java hljs">	ArrayAdapter adapter = new ArrayAdapter<String>(this, 
			android.R.layout.simple_list_item_single_choice, 
			files);
	listView.setAdapter(adapter); 
</code>
</pre>		
	</p>
	<p>
	  List view の item のタッチ操作を取得するため、ListView オブジェクトに対して、<strong>setOnItemClickListener()</strong> メソッドにて、<strong>AdapterView.OnItemClickListener</strong> を設定し、<strong>onItemClick() </strong>メソッドの実装にて、必要な処理を行う。
    <pre>
<code class="java hljs">	public class ... extends ... implements AdapterView.OnItemClickListener {
		...
			listView.setOnItemClickListener(this);
		...
		public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {
			...
		}
	}
</code>
</pre>		
	</p>
	<p>
		また、root directory と新しい directory の名前を File コンストラクタに渡すことにより、Nest Directory（ネスト ディレクトリ）を作成したり、内部ディレクトリを開いたりすることができる。</p>

<pre><code class="java hljs">	File directory = getFilesDir();
	File file = new File(directory, filename);
</code>
</pre>
</div>

<!------------------------------------------------------->
<!-------------------Read a File Content----------------->
<!------------------------------------------------------->
<div class="practice">
	<h3>演習問題4_3: Read a text file（必須）</h3>
  <p>「ファイルの中身を読み込む」の説明を参考に、以下の内容を実施せよ。</p>

	<ol type="a">
		<li>演習問題4_2で作成した list view のファイルにタッチしたとき、content view が layout_input に戻り、TextView に、タッチしたファイルの名前が表示されるようにする（図５を参照）。
		</li>
		<li>
			「Edit」メニューをタッチしたとき、TextView に、ファイルの中身が表示されるようにする（図６を参照）。
		</li>
	</ol>
			
	<table><tr>
		<td align="center">
			<figure class="figure">
				<img src="./assets/images/ex4th/opening_content_file.png" alt="opening_content_file.png" class="figure-img img-fluid rounded" width="80%">
				<figcaption class="figure-caption text-center">図５．前画面でファイルを選択した後、そのファイル名がTextView に表示される結果</figcaption>
			</figure>
		</td>
		<td align="center">
			<figure class="figure">
				<img src="./assets/images/ex4th/viewing_content_file.png" alt="viewing_content_file.png" class="figure-img img-fluid rounded" width="80%">
				<figcaption class="figure-caption text-center">図６．「Edit」メニューをタッチした際、TextView に開いたファイルの中身を表示させた結果</figcaption>
			</figure>
		</td>
	</tr></table>
</div>
<h3>ファイルの中身を読み込む / Read a File Content</h3>
<div class="contents">
<p>
	File オブジェクトをFileReaderの生成に用いる方法。
</p>
<pre>
<code class="java hljs">	FileReader fr = new FileReader(file);	
</code></pre>	
	<p>
    ストリームを使用してファイルにアクセスすることもできる。ファイルをストリームとして読み取るには、次のように <strong>openFileInput() </strong>を使用する。 </p>
<pre>
<code class="java hljs">	FileInputStream fis = openFileInput("myfilename.txt");
	InputStreamReader inputStreamReader =
			new InputStreamReader(fis, StandardCharsets.UTF_8);
</code></pre>	
</p>
<p>
	<strong> 注: </strong>インストール時にストリームとしてファイルにアクセスする必要がある場合は、ファイルをプロジェクトの /res/raw ディレクトリに保存する。それらのファイルを開くには、openRawResource() を使用し、R.raw プレフィックスを付けたファイル名をリソース ID として渡す。このメソッドから返される InputStream を使用して、ファイルを読み取ることができる。元のファイルに書き込むことはできない。 </p>
<p>
	File reader および、input stream reader から、ファイルの中身を抽出するため、BufferedReader class を用いる。通常の file reader や input stream reader は Byte 配列としてファイルを読み込むのに対して、BufferedReader オブジェクトは文字単位および、文字列（行）単位で読み込むことできます。
<pre>
<code class="java hljs">try {
	BufferedReader reader = new BufferedReader(inputStreamReader);
	int moji = reader.read(); //一文字を読む	
	String line = reader.readLine(); //一行を読む
} catch (IOException e) {
	// Error occurred when opening raw file for reading.
} 
</code></pre>	
</p>
</div>
	

        </div>
    </body>
</html>